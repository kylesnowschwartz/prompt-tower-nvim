-- lua/prompt-tower/init.lua
-- Main entry point for the prompt-tower.nvim plugin

local M = {}

-- Plugin version for compatibility checks
M.version = '0.1.0'

-- Load dependencies
local config = require('prompt-tower.config')
local workspace = require('prompt-tower.services.workspace')

-- Internal state (now using workspace service)
local state = {
  initialized = false,
  last_context = nil,
}

--- Initialize the plugin
--- @return boolean success True if initialization succeeded
function M.setup(opts)
  vim.validate('opts', opts or {}, 'table')

  -- Merge user options with defaults
  config.setup(opts)

  -- Initialize workspace management
  workspace.setup()

  -- Mark as initialized
  state.initialized = true

  return true
end

--- Check if plugin is initialized
--- @return boolean
local function ensure_initialized()
  if not state.initialized then
    -- Auto-initialize with defaults if not explicitly set up
    M.setup({})
  end
  return state.initialized
end

--- Run a command from the user command interface
--- @param args string? Command arguments
function M.run_command(_args)
  if not ensure_initialized() then
    vim.notify('Failed to initialize prompt-tower', vim.log.levels.ERROR)
    return
  end

  -- For now, just open a simple selection interface
  vim.notify('Prompt Tower: Command interface not yet implemented', vim.log.levels.INFO)
end

--- Complete command arguments
--- @param arg_lead string The leading portion of the argument being completed
--- @param cmd_line string The entire command line
--- @param cursor_pos number The cursor position in the command line
--- @return table List of completion candidates
function M.complete_command(_arg_lead, _cmd_line, _cursor_pos)
  return {}
end

--- Add current file to selection
function M.select_current_file()
  if not ensure_initialized() then
    vim.notify('Failed to initialize prompt-tower', vim.log.levels.ERROR)
    return
  end

  local current_file = vim.api.nvim_buf_get_name(0)
  if current_file == '' then
    vim.notify('No file in current buffer', vim.log.levels.WARN)
    return
  end

  -- Use workspace service for selection
  local success = workspace.select_file(current_file)
  if success then
    vim.notify(
      string.format('Added "%s" to Prompt Tower selection', vim.fn.fnamemodify(current_file, ':t')),
      vim.log.levels.INFO
    )
  else
    vim.notify(
      string.format('Could not select "%s" - file not found in workspace', vim.fn.fnamemodify(current_file, ':t')),
      vim.log.levels.WARN
    )
  end
end

--- Generate context from selected files
function M.generate_context()
  if not ensure_initialized() then
    vim.notify('Failed to initialize prompt-tower', vim.log.levels.ERROR)
    return
  end

  local selected_files = workspace.get_selected_files()
  if #selected_files == 0 then
    vim.notify('No files selected for context generation', vim.log.levels.WARN)
    return
  end

  -- Basic context generation (will be enhanced later)
  local context_parts = {}

  -- Add header
  table.insert(context_parts, '<!-- Generated by prompt-tower.nvim -->')
  table.insert(context_parts, string.format('<!-- %d files selected -->', #selected_files))
  table.insert(context_parts, '')

  -- Add workspace info
  local current_workspace = workspace.get_current_workspace()
  if current_workspace then
    table.insert(context_parts, string.format('<!-- Workspace: %s -->', current_workspace))
    table.insert(context_parts, '')
  end

  -- Add each file
  for _, file_node in ipairs(selected_files) do
    local file_content = M._read_file(file_node.path)
    if file_content then
      local relative_path = current_workspace and file_node:get_relative_path(current_workspace) or file_node.path
      table.insert(context_parts, string.format('<file path="%s">', relative_path))
      table.insert(context_parts, file_content)
      table.insert(context_parts, '</file>')
      table.insert(context_parts, '')
    end
  end

  local context = table.concat(context_parts, '\n')
  state.last_context = context

  -- Copy to clipboard
  local clipboard_register = config.get_value('clipboard.register') or '+'
  vim.fn.setreg(clipboard_register, context)

  vim.notify(
    string.format('Generated context with %d files and copied to clipboard', #selected_files),
    vim.log.levels.INFO
  )
end

--- Clear all selected files
function M.clear_selection()
  if not ensure_initialized() then
    vim.notify('Failed to initialize prompt-tower', vim.log.levels.ERROR)
    return
  end

  local count = workspace.get_selection_count()
  workspace.clear_selections()

  vim.notify(string.format('Cleared %d files from selection', count), vim.log.levels.INFO)
end

--- Toggle file selection
--- @param filepath string? File path to toggle, defaults to current file
function M.toggle_selection(filepath)
  if not ensure_initialized() then
    vim.notify('Failed to initialize prompt-tower', vim.log.levels.ERROR)
    return
  end

  local target_file = filepath or vim.api.nvim_buf_get_name(0)
  if target_file == '' then
    vim.notify('No file specified or in current buffer', vim.log.levels.WARN)
    return
  end

  local was_selected = workspace.is_file_selected(target_file)
  local new_state = workspace.toggle_file_selection(target_file)

  if new_state and not was_selected then
    vim.notify(string.format('Added "%s" to selection', vim.fn.fnamemodify(target_file, ':t')), vim.log.levels.INFO)
  elseif not new_state and was_selected then
    vim.notify(string.format('Removed "%s" from selection', vim.fn.fnamemodify(target_file, ':t')), vim.log.levels.INFO)
  else
    vim.notify(
      string.format('Could not toggle selection for "%s"', vim.fn.fnamemodify(target_file, ':t')),
      vim.log.levels.WARN
    )
  end
end

--- Internal helper to read file content
--- @param filepath string Path to the file
--- @return string? content File content or nil if error
function M._read_file(filepath)
  local file = io.open(filepath, 'r')
  if not file then
    vim.notify(string.format('Could not read file: %s', filepath), vim.log.levels.ERROR)
    return nil
  end

  local content = file:read('*all')
  file:close()

  return content
end

--- Get current state for testing
--- @return table Internal state
function M._get_state()
  return state
end

--- Reset state for testing
function M._reset_state()
  state = {
    initialized = false,
    last_context = nil,
  }
  workspace._reset_state()
end

--- Get workspace service for testing
--- @return table Workspace service
function M._get_workspace()
  return workspace
end

return M
